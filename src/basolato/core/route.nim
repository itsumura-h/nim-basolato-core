import
  asynchttpserver, asyncdispatch, json, tables, strformat, macros, strutils, re,
  os
import request, response, header, logger, resources/errorPage, resources/ddPage
export request, header


type Params* = ref object
  urlParams*:JsonNode
  queryParams*:JsonNode
  requestParams*:RequestParams

type Route* = ref object
  httpMethod*: HttpMethod
  path*:string
  action*: proc(request:Request, params:Params):Future[Response]


proc params*(request:Request, route:Route):Params =
  let url = request.path
  let path = route.path
  return Params(
    urlParams: getUrlParams(url, path),
    queryParams: getQueryParams(request),
    requestParams: getRequestParams(request)
  )

type Routes* = ref object
  values*: seq[Route]

proc newRoutes*():Routes =
  return Routes()

proc newRoute(httpMethod:HttpMethod, path:string, action:proc(request:Request, params:Params):Future[Response]):Route =
  return Route(
    httpMethod:httpMethod,
    path:path,
    action:action
  )

proc add*(this:var Routes, httpMethod:HttpMethod, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  this.values.add(
    newRoute(httpMethod, path, action)
  )

proc get*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpGet, path, action)

proc post*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpPost, path, action)

proc put*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpPut, path, action)

proc patch*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpPatch, path, action)

proc delete*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpDelete, path, action)

proc head*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpHead, path, action)

proc options*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpOptions, path, action)

proc trace*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpTrace, path, action)

proc connect*(this:var Routes, path:string, action:proc(request:Request, params:Params):Future[Response]) =
  add(this, HttpConnect, path, action)


const errorStatusArray* = [505, 504, 503, 502, 501, 500, 451, 431, 429, 428, 426,
  422, 421, 418, 417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406,
  405, 404, 403, 401, 400, 307, 305, 304, 303, 302, 301, 300]

macro createHttpCodeError():untyped =
  var strBody = ""
  for num in errorStatusArray:
    strBody.add(fmt"""
of "Error{num.repr}":
  return Http{num.repr}
""")
  return parseStmt(fmt"""
case $exception.name
{strBody}
else:
  return Http400
""")

proc checkHttpCode(exception:ref Exception):HttpCode =
  ## Generated by macro createHttpCodeError.
  ## List is httpCodeArray
  ## .. code-block:: nim
  ##   case $exception.name
  ##   of Error505:
  ##     return Http505
  ##   of Error504:
  ##     return Http504
  ##   of Error503:
  ##     return Http503
  ##   .
  ##   .
  createHttpCodeError


template serve*(routes:var Routes, port=5000) =
  var server = newAsyncHttpServer()
  proc cb(req: Request) {.async, gcsafe.} =
    var headers = newDefaultHeaders()
    var response = render(Http404, errorPage(Http404, ""), headers)
    for route in routes.values:
      try:
        if route.httpMethod == req.httpMethod() and isMatchUrl(req.path, route.path):
          let params = req.params(route)
          response = await route.action(req, params)
          logger($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)
          break
      except Exception:
        let exception = getCurrentException()
        if exception.name == "DD".cstring:
          var msg = exception.msg
          msg = msg.replace(re"Async traceback:[.\s\S]*")
          response = render(Http200, ddPage(msg), headers)
        else:
          let status = checkHttpCode(exception)
          response = render(status, errorPage(status, exception.msg), headers)
          echoErrorMsg($response.status & "  " & req.hostname & "  " & $req.httpMethod & "  " & req.path)
          echoErrorMsg(exception.msg)
          break
    await req.respond(response.status, response.body, response.headers.toResponse())
  waitFor server.serve(Port(port), cb)
